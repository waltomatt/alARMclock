KMD
00000000:             ; ;--------------------------------------------------------
00000000:             ; ;     Matt Walton
00000000:             ; ;     Version 1.0
00000000:             ; ;     29th April 2019
00000000:             ; ;
00000000:             ; ;     EX9 - Final Project (Alarm Clock)
00000000:             ; ;--------------------------------------------------------
00000000:             ; 
00000000:             ; ; os.s
00000000:             ; ; This contains the 'operating system code'
00000000:             ; ; Initialises devices, defines service & interrupt routines
00000000:             ; 
00000000:             ;                 ORG     0x0
00000000: EA00002D    ;                 B       OS_init                           ; defines what to do on reset
00000008:             ;                 ORG     0x8
00000008: EA00004B    ;                 B       OS_svc                            ; defines what to do on svc
00000018:             ;                 ORG     0x18
00000018: EA000055    ;                 B       OS_irq                            ; irq handler
0000001C:             ; 
00000020:             ;                 ORG     0x20
00000020:             ; 
00000020:             ;                 INCLUDE constants.s                       ; include our constants
00000020:             ; ;--------------------------------------------------------
00000020:             ; ;     Matt Walton
00000020:             ; ;     Version 1.0
00000020:             ; ;     29th April 2019
00000020:             ; ;
00000020:             ; ;     EX9 - Final Project (Alarm Clock)
00000020:             ; ;--------------------------------------------------------
00000020:             ; 
00000020:             ; ; constants.s
00000020:             ; ; Defines all constants for the operating system
00000020:             ; 
00000020:             ; bit_7           EQU     &80
00000020:             ; bit_6           EQU     &40
00000020:             ; bit_5           EQU     &20
00000020:             ; bit_4           EQU     &10
00000020:             ; bit_3           EQU     &8
00000020:             ; bit_2           EQU     &4
00000020:             ; bit_1           EQU     &2
00000020:             ; bit_0           EQU     &1
00000020:             ; 
00000020:             ; stack_size      EQU     0x30                ; define the stack size for all user modes
00000020:             ; 
00000020:             ; cpsr_usr        EQU     0x10                ; define the CPSR codes for each mode
00000020:             ; cpsr_fiq        EQU     0x11
00000020:             ; cpsr_irq        EQU     0x12
00000020:             ; cpsr_svc        EQU     0x13
00000020:             ; cpsr_abt        EQU     0x17
00000020:             ; cpsr_und        EQU     0x1B
00000020:             ; cpsr_sys        EQU     0x1F
00000020:             ; 
00000020:             ; base_adr        EQU     0x10000000          ; base address for i/o
00000020:             ; piob_ofs        EQU     0x4                 ; offset for port b
00000020:             ; timer_ofs       EQU     0x8
00000020:             ; ire_ofs         EQU     &1c                 ; offset for interupt enable
00000020:             ; ira_ofs         EQU     &18                 ; offset for interrupt active
00000020:             ; 
00000020:             ; irq_mask        EQU     &80
00000020:             ; 
00000020:             ; ir_timer        EQU     bit_0
00000020:             ; ir_ubutton      EQU     bit_6
00000020:             ; ir_lbutton      EQU     bit_7
00000020:             ; 
00000020:             ; 
00000020:             ; usr_stack       DEFS    stack_size                        ; define the space for all the stacks
00000050:             ; irq_stack       DEFS    stack_size
00000080:             ; svc_stack       DEFS    stack_size
000000B0:             ; 
000000B0: 000000C1    ; ir_enabled      DEFW    ir_ubutton OR ir_lbutton OR ir_timer
000000B4:             ; 
000000B4:             ; svc_jmax        EQU     2
000000B4: 000001F8    ; svc_jumps       DEFW    LCD_write                         ; SVC 0 = LCD_write
000000B8: 00000230    ;                 DEFW    LCD_set_light                     ; SVC 1 = LCD_set_light
000000BC:             ; 
000000BC:             ; ; OS_init - initalises the stacks, interrupts, drivers, etc
000000BC:             ; 
000000BC:             ; OS_init
000000BC: E10F0000    ;                 MRS      R0, CPSR                         ; load CPSR into r0
000000C0: E3C0001F    ;                 BIC      R0, R0, #cpsr_sys                ; clear usermode
000000C4: E380001F    ;                 ORR      R0, R0, #cpsr_sys                ; set user to system
000000C8: E12FF000    ;                 MSR      CPSR, R0                         ; write back cpsr
000000CC: E24FD084    ;                 ADR      SP, usr_stack + stack_size       ; setup usr stack
000000D0:             ; 
000000D0: E3C0001F    ;                 BIC      R0, R0, #cpsr_sys                ; do the same for IRQ
000000D4: E3800012    ;                 ORR      R0, R0, #cpsr_irq
000000D8: E12FF000    ;                 MSR      CPSR, R0
000000DC: E24FD064    ;                 ADR      SP, irq_stack + stack_size
000000E0:             ; 
000000E0: E3C0001F    ;                 BIC      R0, R0, #cpsr_sys                ; and for svc
000000E4: E3800013    ;                 ORR      R0, R0, #cpsr_svc
000000E8: E12FF000    ;                 MSR      CPSR, R0
000000EC: E24FD044    ;                 ADR      SP, svc_stack + stack_size
000000F0:             ; 
000000F0: E3C0001F    ;                 BIC      R0, R0, #cpsr_sys                ; switch back to svc
000000F4: E3800013    ;                 ORR      R0, R0, #cpsr_svc
000000F8: E12FF000    ;                 MSR      CPSR, R0
000000FC:             ; 
000000FC:             ; ; OS procedure to enable IRQ interrupts
000000FC:             ; 
000000FC: E24F0054    ; OS_en_irq       ADR     R0, ir_enabled                    ; load enabled flags
00000100: E5100000    ;                 LDR     R0, [R0]
00000104: E3A01201    ;                 MOV     R1, #base_adr
00000108: E281101C    ;                 ADD     R1, R1, #ire_ofs
0000010C: E5010000    ;                 STR     R0, [R1]                          ; enable our interrupts
00000110: E10F0000    ;                 MRS     R0, CPSR
00000114: E3C00080    ;                 BIC     R0, R0, #irq_mask                 ; enable IRQ on CPU
00000118: E12FF000    ;                 MSR     CPSR, R0
0000011C:             ; 
0000011C: E3A01001    ; OS_init_lcd     MOV     R1, #lcd_cmd_clr                  ; clear our lcd screen
00000120: E3A00000    ;                 MOV     R0, #0                            ; 0 = command
00000124: EF000000    ;                 SVC     0
00000128:             ; 
00000128: E10F0000    ; OS_program      MRS     R0, CPSR
0000012C: E3C0001F    ;                 BIC     R0, R0, #cpsr_sys
00000130: E3800010    ;                 ORR     R0, R0, #cpsr_usr                 ; set mode to user
00000134: E12FF000    ;                 MSR     CPSR,  R0
00000138: EA0000B9    ;                 B       Main                              ; branch to main program
0000013C:             ; 
0000013C:             ; ; SVC entry point
0000013C:             ; 
0000013C: E92D4000    ; OS_svc          STMFD   SP!, {LR}
00000140: E51EE004    ;                 LDR     R14, [LR, #-4]                    ; copy the calling inst (ret adr - 4)
                      ;  to R1
00000144: E3CEE4FF    ;                 BIC     R14, R14, #&FF000000              ; mask off opcode
00000148: E35E0002    ;                 CMP     R14, #svc_jmax                    ; validation of svc code
0000014C: 5A000006    ;                 BPL     svc_done                          ; svc code > max
00000150: E35E0000    ;                 CMP     R14, #0                           ; svc code < 0
00000154: 4A000004    ;                 BMI     svc_done
00000158: E92D0001    ;                 STMFD   SP!, {R0}                         ; push r0
0000015C: E24F00B0    ;                 ADR     R0, svc_jumps                     ; get adr of jump table
00000160: E080E10E    ;                 ADD     R14, R0, R14 LSL #2               ; add R0 * 4
00000164: E8BD0001    ;                 LDMFD   SP!, {R0}                         ; pop r0
00000168: E51EF000    ;                 LDR     PC, [R14]
0000016C:             ; 
0000016C:             ; ; procedure to be called at the end of a service routine, returns us back
0000016C: E8BD4000    ; svc_done        LDMFD   SP!, {LR}
00000170: E1B0F00E    ;                 MOVS    PC, LR
00000174:             ; 
00000174:             ; ; Interrupt service routine
00000174:             ; 
00000174: E24EE004    ; OS_irq          SUB     LR, LR, #4
00000178: E92D4007    ;                 STMFD   SP!, {R0-R2, LR}                 ; Store working regs & return adr
0000017C: E3A01201    ;                 MOV     R1, #base_adr                    ; check which interrupt fired
00000180: E2811018    ;                 ADD     R1, R1, #ira_ofs
00000184: E5510000    ;                 LDRB    R0, [R1]
00000188: E3100040    ;                 TST     R0, #ir_ubutton                  ; check if upper button
0000018C: 13C00040    ;                 BICNE   R0, R0, #ir_ubutton              ; mark done
00000190: 1B000007    ;                 BLNE    Ubutton_press                    ; run routine
00000194: E3100080    ;                 TST     R0, #ir_lbutton                  ; check lower button
00000198: 13C00080    ;                 BICNE   R0, R0, #ir_lbutton
0000019C: 1B000005    ;                 BLNE    Lbutton_press
000001A0: E3100001    ;                 TST     R0, #ir_timer                    ; check timer
000001A4: 13C00001    ;                 BICNE   R0, R0, #ir_timer
000001A8: 1B00002F    ;                 BLNE    Clock_update
000001AC: E5410000    ;                 STRB    R0, [R1]                         ; acknowledge interrupt
000001B0: E8FD8007    ; isr_done        LDMFD   SP!, {R0-R2, PC}^                ; restore & return
000001B4:             ; 
000001B4: E1A0F00E    ; Ubutton_press   MOV     PC, LR
000001B8: E1A0F00E    ; Lbutton_press   MOV     PC, LR
000001BC:             ; 
000001BC:             ; ; include drivers
000001BC:             ;                 INCLUDE drivers/lcd.s
000001BC:             ; ;---------------------------------------------------------------------------
000001BC:             ; ;       Matt Walton
000001BC:             ; ;       Version 1.0
000001BC:             ; ;       19th March 2019
000001BC:             ; ;
000001BC:             ; ;       This is an implementation for a LCD Driver
000001BC:             ; ;
000001BC:             ; ;---------------------------------------------------------------------------
000001BC:             ; 
000001BC:             ; lcd_cmd_clr   EQU   &1
000001BC:             ; lcd_rw        EQU   bit_2
000001BC:             ; lcd_rs        EQU   bit_1
000001BC:             ; lcd_e         EQU   bit_0
000001BC:             ; lcd_light     EQU   bit_5
000001BC:             ; 
000001BC:             ; 
000001BC:             ; ; Procedure to check if the LCD is ready & wait until it is
000001BC: E92D4007    ; LCD_ready     STMFD SP!, {LR, R0, R1, R2}
000001C0: E3A00201    ;               MOV   R0, #base_adr               ; portA adr
000001C4: E5D01004    ;               LDRB  R1, [R0, #piob_ofs]         ; load contents of port B
000001C8: E3811004    ;               ORR   R1, R1, #lcd_rw             ; set r/w bit to 1
000001CC: E3C11002    ;               BIC   R1, R1, #lcd_rs             ; set RS=0
000001D0: E5C01004    ;               STRB  R1, [R0, #piob_ofs]         ; write cmd to port B
000001D4: E3811001    ; wr_loop       ORR   R1, R1, #lcd_e              ; set E=1
000001D8: E5C01004    ;               STRB  R1, [R0, #piob_ofs]         ; write data to port B
000001DC: E5502000    ;               LDRB  R2, [R0]                    ; read our status bytes
000001E0: E3C11001    ;               BIC   R1, R1, #lcd_e              ; set E=0
000001E4: E5C01004    ;               STRB  R1, [R0, #piob_ofs]         ; write command back
000001E8: E2022080    ;               AND   R2, R2, #bit_7
000001EC: E2522080    ;               SUBS  R2, R2, #bit_7
000001F0: 0AFFFFF7    ;               BEQ   wr_loop                     ; we are still busy, poll again
000001F4: E8BD8007    ;               LDMFD SP!, {PC, R0, R1, R2}       ; pop & return
000001F8:             ; 
000001F8:             ; ; procedure to either write a cmd or data to the lcd
000001F8:             ; ; R0 (1/0) specifies the value of RS (0 - cmd, 1- data)
000001F8:             ; ; R1 specifies the cmd/character
000001F8: E92D400C    ; LCD_write     STMFD SP!, {LR, R2, R3}
000001FC: EBFFFFEE    ;               BL    LCD_ready                   ; wait for lcd to be ready
00000200: E3A02201    ;               MOV   R2, #base_adr               ; load adr of port A into R2
00000204: E5D23004    ;               LDRB  R3, [R2, #piob_ofs]         ; load ctrl byte to r3
00000208: E3C33006    ;               BIC   R3, R3, #(lcd_rw OR lcd_rs) ; set RW=0 & RS=0 (we're writing)
0000020C: E1833080    ;               ORR   R3, R3, R0 lsl #1           ; set RS=R0
00000210: E5C23004    ;               STRB  R3, [R2, #piob_ofs]         ; store back in port B
00000214: E5421000    ;               STRB  R1, [R2]                    ; store our data
00000218: E3833001    ;               ORR   R3, R3, #lcd_e              ; set E=1
0000021C: E5C23004    ;               STRB  R3, [R2, #piob_ofs]         ; store back
00000220: E3C33001    ;               BIC   R3, R3, #lcd_e              ; set E=0
00000224: E5C23004    ;               STRB  R3, [R2, #piob_ofs]         ; store back
00000228: E8BD400C    ;               LDMFD SP!, {LR, R2, R3}
0000022C: EAFFFFCE    ;               B     svc_done
00000230:             ; 
00000230:             ; ; procedure to set the LCD backlight to on/off
00000230:             ; ; R0 specifies 0 for off and 1 for on
00000230:             ; 
00000230: E92D4006    ; LCD_set_light STMFD SP!, {LR, R1, R2}
00000234: E3A01201    ;               MOV   R1, #base_adr
00000238: E5D12004    ;               LDRB  R2, [R1, #piob_ofs]         ; load piob
0000023C: E3500000    ;               CMP   R0, #0                      ; check if we wanna turn it off
00000240: 03C22020    ;               BICEQ R2, R2, #lcd_light          ; clear bit if 0
00000244: 13822020    ;               ORRNE R2, R2, #lcd_light          ; activate bit if 1
00000248: E5C12004    ;               STRB  R2, [R1, #piob_ofs]         ; save back
0000024C: E8BD4006    ;               LDMFD SP!, {LR, R1, R2}
00000250: EAFFFFC5    ;               B     svc_done
00000254:             ; 
00000254:             ; 
00000254:             ; ; include components
00000254:             ;                 INCLUDE clock.s
00000254:             ; ;--------------------------------------------------------
00000254:             ; ;     Matt Walton
00000254:             ; ;     Version 1.0
00000254:             ; ;     29th April 2019
00000254:             ; ;
00000254:             ; ;     EX9 - Final Project (Alarm Clock)
00000254:             ; ;--------------------------------------------------------
00000254:             ; 
00000254:             ; ; clock.s
00000254:             ; ; This contains the code for keeping track of the current time
00000254:             ; 
00000254: 00002328    ; clock_time      DEFW    9000                 ; current time since midnight in seconds
00000258: 00000000    ; clock_count     DEFW    0                 ; count to keep track before incrementing seconds
0000025C:             ; 
0000025C: 00000000    ; clock_mode      DEFW    0                 ; 0 = 24 hours clock, 1 = 12 hour am/pm clock
00000260: 00000000    ; clock_show      DEFW    0                 ; whether to display the time or not (disabled when m
                      ; enu open etc)
00000264: 00000000    ; clock_secs      DEFW    0                 ; whether to display seconds on the clock
00000268:             ; 
00000268:             ; secs_in_min     EQU     60
00000268:             ; secs_in_hour    EQU     3600
00000268: 00015180    ; secs_in_day     DEFW    86400
0000026C:             ; 
0000026C:             ; colon_code      EQU     0x3A              ; ascii code for :
0000026C:             ; 
0000026C:             ; ; Called by the timer interrupt every 256ms, so count to 3 then add a second
0000026C: E92D400F    ; Clock_update    STMFD   SP!, {LR, R0-R3}
00000270: E24F0020    ;                 ADR     R0, clock_count
00000274: E5101000    ;                 LDR     R1, [R0]
00000278: E3510003    ;                 CMP     R1, #3            ; check if we need to update the time
0000027C: 12811001    ;                 ADDNE   R1, R1, #1        ; add 1 to count
00000280: 03A01000    ;                 MOVEQ   R1, #0            ; reset if equal
00000284: 1A000005    ;                 BNE     cu_done
00000288: E24F203C    ;                 ADR     R2, clock_time    ; update clock time
0000028C: E5123000    ;                 LDR     R3, [R2]
00000290: E2833001    ;                 ADD     R3, R3, #1
00000294: E5023000    ;                 STR     R3, [R2]
00000298: EB000007    ;                 BL      Clock_check       ; call function to check next day / alarms
0000029C: EB00001C    ;                 BL      Clock_display
000002A0:             ; ;               BL      Alarm_check
000002A0: E5001000    ; cu_done         STR     R1, [R0]
000002A4: E8BD800F    ;                 LDMFD   SP!, {PC, R0-R3}
000002A8:             ; 
000002A8:             ; ; Called when setting the time of the clock
000002A8:             ; ; inputs: R0 = time since midnight in seconds
000002A8:             ; 
000002A8: E92D4002    ; Clock_set       STMFD   SP!, {LR, R1}
000002AC: E24F1060    ;                 ADR     R1, clock_time
000002B0: E5010000    ;                 STR     R0, [R1]
000002B4: EB000000    ;                 BL      Clock_check
000002B8: E8BD8002    ;                 LDMFD   SP!, {PC, R1}
000002BC:             ; 
000002BC:             ; 
000002BC:             ; ; Checks if we need to roll over to a new day & call alarm checks
000002BC: E92D4007    ; Clock_check     STMFD   SP!, {LR, R0-R2}
000002C0: E24F1074    ;                 ADR     R1, clock_time
000002C4: E5110000    ;                 LDR     R0, [R1]
000002C8: E24F2068    ;                 ADR     R2, secs_in_day
000002CC: E5122000    ;                 LDR     R2, [R2]
000002D0: E1500002    ;                 CMP     R0, R2
000002D4: A3A00000    ;                 MOVGE   R0, #0                ; reset clock to 0 if >= secs_in_day
000002D8: A5010000    ;                 STRGE   R0, [R1]
000002DC: E8BD8007    ;                 LDMFD   SP!, {PC, R0-R2}
000002E0:             ; 
000002E0:             ; 
000002E0:             ; ; Converts seconds since midnight into hours, minutes, seconds
000002E0:             ; ; inputs: R0 = time since midnight in seconds
000002E0:             ; ; outputs: R0 = seconds , R1 = minutes, R2 = hours
000002E0:             ; 
000002E0: E3A01000    ; Clock_format    MOV     R1, #0                ; zero hours, mins
000002E4: E3A02000    ;                 MOV     R2, #0
000002E8: E3500EE1    ; cf_s_hours      CMP     R0, #secs_in_hour
000002EC: BA000002    ;                 BLT     cf_s_mins             ; no more hours left
000002F0: E2822001    ;                 ADD     R2, R2, #1
000002F4: E2400EE1    ;                 SUB     R0, R0, #secs_in_hour
000002F8: EAFFFFFA    ;                 B       cf_s_hours
000002FC: E350003C    ; cf_s_mins       CMP     R0, #secs_in_min      ; check mins
00000300: BA000002    ;                 BLT     cf_done
00000304: E2811001    ;                 ADD     R1, R1, #1
00000308: E240003C    ;                 SUB     R0, R0, #secs_in_min
0000030C: EAFFFFFA    ;                 B       cf_s_mins
00000310: E1A0F00E    ; cf_done         MOV     PC, LR                ; we're done and left with seconds in R0
00000314:             ; 
00000314:             ; 
00000314:             ; ; Displays the current time on the LCD screen
00000314: E92D400F    ; Clock_display   STMFD   SP!, {LR, R0-R3}
00000318: E24F00C0    ;                 ADR     R0, clock_show        ; check if we should display the time
0000031C: E5100000    ;                 LDR     R0, [R0]
00000320: E3500000    ;                 CMP     R0, #0
00000324: 0A000012    ;                 BEQ     cd_done  
00000328: EB00002E    ;                 BL      LCD_Clear             ; clear the screen
0000032C: E24F00E0    ;                 ADR     R0, clock_time        ; load time
00000330: E5100000    ;                 LDR     R0, [R0]
00000334: EBFFFFE9    ;                 BL      Clock_format          ; format into sec, min, hr
00000338: E1A03000    ;                 MOV     R3, R0                ; move secs into r3 for now
0000033C: E1A00002    ;                 MOV     R0, R2                ; move hours into R0 to print
00000340: EB00002E    ;                 BL      LCD_Write_num
00000344: E3A0003A    ;                 MOV     R0, #colon_code       ; print a colon
00000348: EB000014    ;                 BL      LCD_Write_char
0000034C: E1A00001    ;                 MOV     R0, R1                ; move mins into r0 & print
00000350: EB00002A    ;                 BL      LCD_Write_num
00000354: E24F00F8    ;                 ADR     R0, clock_secs        ; check if we should display seconds
00000358: E5100000    ;                 LDR     R0, [R0]
0000035C: E3500000    ;                 CMP     R0, #0
00000360: 0A000003    ;                 BEQ     cd_done               ; skip over the seconds
00000364: E3A0003A    ;                 MOV     R0, #colon_code
00000368: EB00000C    ;                 BL      LCD_Write_char
0000036C: E1A00003    ;                 MOV     R0, R3                ; move seconds back & print
00000370: EB000022    ;                 BL      LCD_Write_num
00000374: E8BD800F    ; cd_done         LDMFD   SP!, {PC, R0-R3}
00000378:             ; 
00000378:             ;                 INCLUDE util.s
00000378:             ; ; Divide10 procedure
00000378:             ; ; R0 = number to divide
00000378:             ; ; returns the divided value in R0, remainder in R1
00000378: 1999999A    ; divisor10       DEFW    &1999999A             ; ~2^32/10
0000037C: E92D400C    ; Divide10        STMFD   SP!, {LR, R2, R3}
00000380: E24F1010    ;                 ADR     R1, divisor10
00000384: E5111000    ;                 LDR     R1, [R1]
00000388: E0832190    ;                 UMULL   R2, R3, R0, R1        ; we're essentially doing n * 2^32/1000 then divi
                      ; ding by 2^32
0000038C: E3A0100A    ;                 MOV     R1, #10
00000390: E0010193    ;                 MUL     R1, R3, R1            ; mul back by 10
00000394: E0401001    ;                 SUB     R1, R0, R1            ; remainder into r1
00000398: E1A00003    ;                 MOV     R0, R3                ; move divided value to R0
0000039C: E8BD800C    ;                 LDMFD   SP!, {PC, R2, R3}
000003A0:             ; 
000003A0:             ; 
000003A0:             ; ; include program
000003A0:             ;                 INCLUDE program.s
000003A0:             ; INCLUDE   includes/lcd.s
000003A0:             ; ;---------------------------------------------------------------------------
000003A0:             ; ;       Matt Walton
000003A0:             ; ;       Version 1.0
000003A0:             ; ;       18th February 2019
000003A0:             ; ;
000003A0:             ; ;       This program implements my previous code for writing to an LCD
000003A0:             ; ;       but instead making sure the driver is run in supervisor mode
000003A0:             ; ;       and calls are made from user code to this via SVC calls.
000003A0:             ; ;
000003A0:             ; ;---------------------------------------------------------------------------
000003A0:             ; 
000003A0:             ; ; lcd.s
000003A0:             ; ; this provides functions to make calls to the LCD driver a bit nicer
000003A0:             ; 
000003A0:             ; lcd_code_clear  EQU   1
000003A0:             ; 
000003A0:             ; ; Procedure to write a character to the LCD using the SVC call
000003A0:             ; ; R0 = character
000003A0: E92D4003    ; LCD_Write_char  STMFD SP!, {LR, R1 ,R0}
000003A4: E1A01000    ;                 MOV   R1, R0            ; move our value at R0 to R1
000003A8: E3A00001    ;                 MOV   R0, #1            ; we want to write a character
000003AC: EF000000    ;                 SVC   0                 ; Call our service routine
000003B0: E8BD8003    ;                 LDMFD SP!, {PC, R1, R0}
000003B4:             ; 
000003B4:             ; 
000003B4:             ; ; Procedure to send a command to the LCD controller
000003B4:             ; ; R0 = cmd
000003B4: E92D4003    ; LCD_Write_cmd   STMFD SP!, {LR, R1 ,R0}
000003B8: E1A01000    ;                 MOV   R1, R0            ; move our value at R0 to R1
000003BC: E3A00000    ;                 MOV   R0, #0            ; we want to send a command
000003C0: EF000000    ;                 SVC   0                 ; Call our service routine
000003C4: E8BD8003    ;                 LDMFD SP!, {PC, R1, R0}
000003C8:             ; 
000003C8:             ; ; Procedure to write a string to the LCD
000003C8:             ; ; R0 = start address of string
000003C8:             ; ; The procedure will continue until a null byte string terminator is hit
000003C8:             ; 
000003C8: E92D4003    ; LCD_Write_str   STMFD SP!, {LR, R0, R1}     ; we're using R2, and want to push the LR to the st
                      ; ack
000003CC: E1A01000    ;                 MOV   R1, R0            ; move R0 > R1
000003D0: E4D10001    ; next_byte       LDRB  R0, [R1], #1      ; load our byte into R2 and increment
000003D4: E3500000    ;                 CMP   R0, #0            ; are we at null byte? end of string?
000003D8: 0A000001    ;                 BEQ   wstr_dne
000003DC:             ; 
000003DC: EBFFFFEF    ;                 BL    LCD_Write_char
000003E0: EAFFFFFA    ;                 BAL   next_byte
000003E4: E8BD8003    ; wstr_dne        LDMFD SP!, {PC, R0, R1}     ; pop our registers back and branch back
000003E8:             ; 
000003E8:             ; ; Procedure to clear the screen of the LCD
000003E8: E92D4001    ; LCD_Clear       STMFD SP!, {LR, R0}
000003EC: E3A00001    ;                 MOV   R0, #lcd_code_clear
000003F0: EBFFFFEF    ;                 BL    LCD_Write_cmd
000003F4: E8BD8001    ;                 LDMFD SP!, {PC, R0}
000003F8:             ; 
000003F8:             ; 
000003F8:             ; ; Procedure to set the status of the LCD backlight
000003F8:             ; ; R0 = 1 for on , 0 for off
000003F8:             ; 
000003F8: EF000001    ; LCD_Set_light   SVC   1                     ; just call the service routine
000003FC: E1A0F00E    ;                 MOV   PC, LR
00000400:             ; 
00000400:             ; ; Procedure for writing a 2 digit 0-padded number to the LCD
00000400:             ; ; R0 = number
00000400: E92D4003    ; LCD_Write_num   STMFD SP!, {LR, R0-R1}
00000404: EBFFFFDC    ;                 BL    Divide10              ; now we can just print r0 then r1
00000408: E2800030    ;                 ADD   R0, R0, #&30          ; add 0x30 to them for ascii
0000040C: E2811030    ;                 ADD   R1, R1, #&30
00000410: EBFFFFE2    ;                 BL    LCD_Write_char
00000414: E1A00001    ;                 MOV   R0, R1
00000418: EBFFFFE0    ;                 BL    LCD_Write_char
0000041C: E8BD8003    ;                 LDMFD SP!, {PC, R0-R1}
00000420:             ; 
00000420:             ; ; Procedure to write & pad so that the next thing we write is on the second line
00000420:             ; ; R0 = start address of string
00000420:             ; 
00000420: E92D4003    ; LCD_Write_pad   STMFD SP!, {LR, R0, R1}
00000424:             ; ;                MOV   R2, R0                ; move R0 > R2
00000424:             ; ;                MOV   R1, #0                ; set counter to 0
00000424:             ; ;next_byte       CMP   R1, #40               ; are we at end of line yet
00000424:             ; ;                BEQ   wstr_dne
00000424:             ; ;LDRB  R0, [R2, R1]          ; load our byte into R2 and increment
00000424:             ; 
00000424:             ; ;                BEQ   wstr_dne
00000424:             ; 
00000424:             ; ;                BL    LCD_Write_char
00000424:             ; ;                BAL   next_byte
00000424:             ; ;                wstr_dne        LDMFD SP!, {PC, R0, R1}     ; pop our registers back and branc
                      ; h back
00000424:             ; 
00000424:             ; 
00000424:             ;           ALIGN 4
00000424:             ; 
00000424: EAFFFFFE    ; Main      BAL Main
00000428:             ; 
00000428:             ; 

Symbol Table: Labels
: bit_7                             00000080  Value
: bit_6                             00000040  Value
: bit_5                             00000020  Value
: bit_4                             00000010  Value
: bit_3                             00000008  Value
: bit_2                             00000004  Value
: bit_1                             00000002  Value
: bit_0                             00000001  Value
: stack_size                        00000030  Value
: cpsr_usr                          00000010  Value
: cpsr_fiq                          00000011  Value
: cpsr_irq                          00000012  Value
: cpsr_svc                          00000013  Value
: cpsr_abt                          00000017  Value
: cpsr_und                          0000001B  Value
: cpsr_sys                          0000001F  Value
: base_adr                          10000000  Value
: piob_ofs                          00000004  Value
: timer_ofs                         00000008  Value
: ire_ofs                           0000001C  Value
: ira_ofs                           00000018  Value
: irq_mask                          00000080  Value
: ir_timer                          00000001  Value
: ir_ubutton                        00000040  Value
: ir_lbutton                        00000080  Value
: usr_stack                         00000020  Local -- ARM
: irq_stack                         00000050  Local -- ARM
: svc_stack                         00000080  Local -- ARM
: ir_enabled                        000000B0  Local -- ARM
: svc_jmax                          00000002  Value
: svc_jumps                         000000B4  Local -- ARM
: OS_init                           000000BC  Local -- ARM
: OS_en_irq                         000000FC  Local -- ARM
: OS_init_lcd                       0000011C  Local -- ARM
: OS_program                        00000128  Local -- ARM
: OS_svc                            0000013C  Local -- ARM
: svc_done                          0000016C  Local -- ARM
: OS_irq                            00000174  Local -- ARM
: isr_done                          000001B0  Local -- ARM
: Ubutton_press                     000001B4  Local -- ARM
: Lbutton_press                     000001B8  Local -- ARM
: lcd_cmd_clr                       00000001  Value
: lcd_rw                            00000004  Value
: lcd_rs                            00000002  Value
: lcd_e                             00000001  Value
: lcd_light                         00000020  Value
: LCD_ready                         000001BC  Local -- ARM
: wr_loop                           000001D4  Local -- ARM
: LCD_write                         000001F8  Local -- ARM
: LCD_set_light                     00000230  Local -- ARM
: clock_time                        00000254  Local -- ARM
: clock_count                       00000258  Local -- ARM
: clock_mode                        0000025C  Local -- ARM
: clock_show                        00000260  Local -- ARM
: clock_secs                        00000264  Local -- ARM
: secs_in_min                       0000003C  Value
: secs_in_hour                      00000E10  Value
: secs_in_day                       00000268  Local -- ARM
: colon_code                        0000003A  Value
: Clock_update                      0000026C  Local -- ARM
: cu_done                           000002A0  Local -- ARM
: Clock_set                         000002A8  Local -- ARM
: Clock_check                       000002BC  Local -- ARM
: Clock_format                      000002E0  Local -- ARM
: cf_s_hours                        000002E8  Local -- ARM
: cf_s_mins                         000002FC  Local -- ARM
: cf_done                           00000310  Local -- ARM
: Clock_display                     00000314  Local -- ARM
: cd_done                           00000374  Local -- ARM
: divisor10                         00000378  Local -- ARM
: Divide10                          0000037C  Local -- ARM
: lcd_code_clear                    00000001  Value
: LCD_Write_char                    000003A0  Local -- ARM
: LCD_Write_cmd                     000003B4  Local -- ARM
: LCD_Write_str                     000003C8  Local -- ARM
: next_byte                         000003D0  Local -- ARM
: wstr_dne                          000003E4  Local -- ARM
: LCD_Clear                         000003E8  Local -- ARM
: LCD_Set_light                     000003F8  Local -- ARM
: LCD_Write_num                     00000400  Local -- ARM
: LCD_Write_pad                     00000420  Local -- ARM
: Main                              00000424  Local -- ARM
